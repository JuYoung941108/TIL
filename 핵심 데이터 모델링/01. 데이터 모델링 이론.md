# 🟢데이터 모델
- 현실 세계의 정보나 데이터를 시스템으로 구축하기 위해 추상화하여 체계적으로 표현한 모형
- 개체관계 모델(ER, Entity-Relationship Model), 계층 모델(Hierachical Model), 망 모델(Network Model)

# 🟢데이터 모델링
- 데이터 시스템 구조를 형상화하는 과정

# 🟢ER모델(Entity-Relationship Model)
- 표현하고자 업무를 개체, 관계 두가지 개념으로 표현
- ERD(Entity-Relationshop Diagram): ER 모델에서 사용하는 실체와 관계를 도식화
> ER 모델의 질적 특성
1. 완전성(Completeness): 모든 요구사항을 표현
2. 정확성(Correctness): 관계, 엔티티, 식별자, 카디널리티(Cardinality), 옵셔널리티(Optionality) 등을 명확하게 표기
3. 최소성(Minimality): 중복성 제거
4. 자명성(Self-explanation), 표현성(Expressiveness): 알아보기 쉽게 직관적으로 작성
5. 확장성(Extensibility): 유연한 모델 설계
6. 가독성(Readability): 뜻을 쉽게 알아차릴 수 있도록 표현
> 카디널리티(Cardinality)와 옵셔널리티(Optionality)
- 카디널리티(Cardinality)
  - 양쪽의 Entity 관계를 나타낸다.(1:n, n:1, n:n)
- 옵셔널리티(Optionality)
  - Entity에 해당 속성이 반드시 특정 값을 가져야 하는지에 대한 구분을 의미
  - Mandatory(반드시 존재해야 함), Conditional(존재하지 않을 수 있음)
## 🔵ER 모델의 구성 요소
### 🟠엔티티(Entity)
- 실제로 존재하거나 개념적이다.
- 다른 존재나 실체로부터 독립적이다.
- 인스턴스를 식별할 수 있는 속성이나 관계가 하나 이상 정의되어야 한다.
> 슈퍼타입 엔티티와 서브타입 엔티티
- 슈퍼타입 엔티티
  - 하나 이상의 서브타입 엔티티와 관계된 일반화된 엔티티로 서브타입에 공통으로 존재하는 속성을 관리한다.
- 서브타입 엔티티
  - 각각의 서브타입에만 존재하는 고유한 속성을 관리한다.
  - 슈퍼타입의 식별자, 속성, 관계 등 모든 특성을 상속받는다.
> 일반화(Generalization)
- 엔티티의 고유한 특성을 일반화하여 공통의 속성으로 재정의
- 개인+기업=고객, 제품+상품=상품
- 두개 이상의 하위 엔티티를 결합하여 상위 수준의 엔티티로 통합하는 상향식 접근 방식
- 엔티티 간의 배타 관계를 해소하여 업무 관계를 단순하게 정의할 수 있다.
- 개별 엔티티에서 관리하던 고유 속성의 의미가 불분명해질 수 있고, 참조 무결성 및 도메인 무결성을 제대로 반영하지 못할 수 있다.
> 특수화(Specialization)
- 일반화와 반대로 하나의 상위 엔티티를 두개 이상의 하위 엔티티로 분할하는 하향식 접근 방식
> 집단화(Aggregation)
- 다른 관계를 포함하는 관계를 포함할 수 없다.
- 집단화는 하나의 엔티티로 취급되는 두개의 엔티티를 재정의 한 것으로 해당 엔티티와의 관계가 상위 수준 엔티티로 대체된다.
> 엔티티(Entity) 분류 <br>
  - 관계에 따른 Entity
    - 강한(Strong) 엔티티: 독립적으로 존재하며 엔티티 내 자체 식별자를 사용한다. <br>
    - 약한(Weak) 엔티티: 다른 엔티티에 정속적이며 다른 엔티티의 식별자를 상속받는다. <br>
  - 형태에 따른 Entity <br>
    - 독립(Kernel, Master) 엔티티: 현실에 존재하는 엔티티(고객, 상품 등) <br>
    - 업무중심(Transaction) 엔티티: 업무를 처리하면서 발생하는 데이터에 해당하는 엔티티로 가장 핵심이 되는 엔티티(주문, 결제 배송 등) <br>
    - 종속(Dependent) 엔티티: 업무중심 엔티티에서 1차 정규화로 분리된 종속 엔티티(주문 상품, 주문 배송 등) <br>
    - 교차(Associative, Relative) 엔티티: 트랜잭션에 의해 생성되는 엔티티로 논리 모델링에서 다대다 관계를 해소하기 위해 도출된 엔티티 [참고 자료](https://goodteacher.tistory.com/466) <br>
  - 생성 관점에 따른 Entity <br>
    - 핵심(Key) 엔티티: 부모 엔티티를 갖지않는 핵심 엔티티
    - 중요(Main) 엔티티: 거래 관계에 의해 생성되는 엔티티로 업무의 핵심이 되는 엔티티
    - 행위(Action) 엔티티: 실제 업무 행위에 의해 지속적으로 발생하는 행위에 대한 엔티티
  - 실체에 따른 Entity <br>
    - 실체(Tangible) 엔티티: 눈으로 볼 수 있는 물리적 형태의 엔티티
    - 비실체(Intangible) 엔티티
      - 개념 엔티티: 물리적인 형태는 없나 개념적으로 존재하는 엔티티(조직, 보험 상품, 서비스 등)
      - 사건(Event) 엔티티: 데이터가 빈번히 생성되고 변경되는 엔티티(계약, 주문 결제 등)
### 🟠관계(Relationship)
- 업무 규칙과 관계를 표현한다.
> 관계(Relationship) 구성 <br>
  - 관계수(Cardinality)
    - 다른 엔티티와 몇개(1, m)의 인스턴스와 구성될 수 있는지 표기한 것으로 최대 인스턴스 수와 관련있다.(1==null, m==Crow's foot)
    - 일대일(1:1)
      - 엔티티 개체 하나가 다른 엔티티 개체 하나만 관계를 가진다.
    - 일대다(1:M)
      - 엔티티 개체 하나가 다른 엔티티 개체 여러 개와 관계를 가진다.
    - 다대다(M:N)
      - 엔티티 개체 하나가 다른 엔티티 개체 여러 개와 관련이 있고, 다른 엔티티 개체 하나는 어떤 엔티티 개체 여러개와 관련이 있다.
  - 선택성(Optionality)
    - 상대 엔티티의 인스턴스가 반드시 존재해야하는지에 대한 여부를 표기한 것으로 최소 인스턴스 수와 관련있다. (Bar(-)==Mandatory(필수적), ○==Optional(선택적))
    - 필수(Mandatory)-필수(Mandatory)
      - 상대 엔티티의 인스턴스를 서로 필요로한다.
    - 필수(Mandatory)-선택(Optional)
      - 하나의 엔티티에서만 상대 엔티티의 인스턴스를 필요로한다.
    - 선택(Optional)-선택(Optional)
      - 상대 엔티티의 인스턴스를 필수적으로 필요로 하지않는다.
  - 식별성(Identifier Inheritance)
    - 엔티티 간의 식별 관계를 표기한다.(실선==식별자 상속, 점선==비식별자 상속)
    ![](https://velog.velcdn.com/images/wruoma/post/5a7f25aa-abfa-475a-8ec0-31f42f471209/image.png)
    - 식별/비식별 관계
      - 식별 관계: 상위 엔티티 식별자가 하위 엔티티의 식별자로 상속되는 경우
      - 비식별 관계: 식별자가 아닌 일반 속성으로 상속되는 경우
  - 관계명(Relationship Name)
    - 관계의 의미/이름을 표기하며 관계선으로 식별할 수 있는 경우 생략 가능하다.
    - 기본 관계
      - 엔티티와 엔티티가 하나의 관계를 맺는다.(1:1, 1:M)
    - 재귀적 관계(순환 관계)
      - 다른 엔티티가 아닌 자기 자신과 관계를 맺는다.
      - 계층 구조에 유용하며, 반드시 Optional 관계를 갖는다.
    - 병렬 관계
      - 엔티티와 엔티티 간에 두개 이상의 관계를 맺는다.
    - 슈퍼타입/서브타입 관계
      - 배타적/포괄적인 관계를 가진다.
      - 슈퍼타입 엔티티는 서브타입 엔티티 중 하나에 반드시 속한다.
### 🟠속성(Attribute)
  - 속성의 의미로 엔티티 특성이나 상태를 알 수 있다.
  - 단순 속성과 복합 속성: 분해할 수 없는 원자 값(고객명, 이메일 등)
> 저장 속성과 파생 속성 <br>
- 저장 속성 <br>
  - 원래 존재하는 속성 <br>
- 파생 속성 <br>
  - 저장 속성이나 다른 파생 속성으로부터 파생된 속성(상품 단가＊주문 수량=주문 금액) <br>
  - 별도로 도출하지 않는 것이 원칙이나 도출하지 않는 경우 데이터를 재현할 수 있는지 확인해야한다. <br>

> 단일 값 속성과 다중 값 속성 <br>
- 단일 값 속성: 하나의 값만 가지는 속성(성별, 생일 등) <br>
- 다중 값 속성: 모델링 과정에서 정규화를 통해 별도의 엔티티로 분리된다.(취미 등) <br>
### 🟠식별자(Identifier)
  - 엔티티에서 인스턴스를 개별적으로 식별할 수 있는 속성들을 의미한다.
  > 식별자의 특징
  1. 유일성(Uniqueness): 엔티티의 모든 인스턴스를 유일하게 식별할 수 있다.
  2. 최소성(Minimum): 유일성을 만족하는 최소 속성들로 구성한다.
  3. 불변성(Stability): 엔티티의 식별자를 지정하면 해당 식별자의 값은 변하지 않아야한다.
  4. 존재성(Mandatory): 식별자는 반드시 데이터 값이 존재해야한다.(Not Null)

# 🟢관계형 데이터 모델 이론
![](https://velog.velcdn.com/images/wruoma/post/c26c4d51-40ef-4073-b7a6-7d365daee61a/image.png) <br>
릴레이션(Relation): 행과 열로 정의한 테이블 <br>
스키마(Schema): 릴레이션의 구조를 정의 <br>
어트리뷰트(Attribute): 릴레이션을 구성하는 열(Column) <br>
튜플(Tuple): 릴레이션을 구성하는 인스턴스(Instance) 데이터 <br>
> - 튜플은 중복을 허용하지 않는다.
> - 어트리뷰트 명칭은 유일해야 하지만 값은 동일해도 상관없다.
## 🔵관계형 모델의 키
 - 슈퍼 키(Super key)
   - 튜플을 식별할 수 있는 속성 집합
   - 슈퍼 키 값은 모든 튜플에서 유일해야한다.(사원번호, 사원명)
 - 후보 키(Candidate Key)
   - 튜플을 고유하게 식별할 수 있는 최소한의 속성 집합
   - 사원번호, 사원명은 슈퍼키에 해당하고, 이 중 최소한의 속성 집합인 '사원번호'가 후보키에 해당한다.
   - 모든 후보키는 슈퍼 키지만, 모든 슈퍼 키가 후보키는 아니다.
 - 기본 키(Primary Key)
   - 릴레이션은 하나 이상의 후보키를 가질 수 없으며 그 중 하나만 기본키로 선택할 수 있다.(사원번호)
   - 후보키와 마찬가지로 유일성, 최소성을 가진다.
 - 대체 키(Alternate Key)
   - 후보키 중 기본키가 아닌 후보키가 대체키에 해당된다.(사원명)
 - 외래 키(Foreign Key)
   - 릴레이션의 어트리뷰트 값이 다른 릴레이션에 속한 어트리뷰트의 기본 키를 참조하는 경우를 뜻한다.
## 🔵제약조건
- 키 제약조건
   - 사원번호처럼 튜플을 유일하게 식별할 수 있는 어트리뷰트들로 구성되며 중복을 허용하지 않는다.
- 실체무결성
   - 릴레이션의 기본키를 구성하는 모든 어트리뷰트는 Null 값이 아니여야하며 오직 하나의 값만 존재해야한다.
- 영역무결성
   - 릴레이션 내 어트리뷰트 값은 정의된 도메인에 속한 값이여야한다.
- 참조무결성
   - 자식 릴레이션의 외래키는 참조하는 부모 릴레이션의 기본키 값 이외의 값을 가질 수 없으며 일관성을 유지해야한다.
## 🔵함수 종속(Functional Dependency)
무결성 제약조건으로 키의 개념을 일반화한 것을 의미한다.
### 🟠 완전 함수종속(Full Functional Dependency)
- [참고 자료](https://ehpub.co.kr/tag/%EC%99%84%EC%A0%84-%ED%95%A8%EC%88%98%EC%A0%81-%EC%A2%85%EC%86%8D-%EA%B4%80%EA%B3%84/)
## 🔵정규화(Normalization)
- 관계형 데이터베이스의 테이블에 대해 데이터를 입력, 수정, 삭제할 때 발생하는 이상(Anomaly) 현상을 최소화하기 위해 작은 단위로 테이블을 설계하는 과정
- 정규화의 장점
  - 데이터 입력, 수정, 삭제 과정에서 이상 현상 최소화 가능
  - 높은 응집력|낮은 결합도|유연성 증가
  - 데이터 재활용성 증가
  - 중복 제거
  - 수행속도 향상
### 🟠제 1정규화
- 관계형 테이블은 중복 열이 없어야 하고, 다중 값이 발생하지 않아야한다.
- 다수 개의 값을 가질 수 있는 어트리뷰트는 분리하고, 정규화에 의해 분리된 테이블은 원래 테이블의 기본키를 상속받는다.
- 분리된 애트리뷰트 중 나머지를 식별할 수 있는 컬럼이 있으면 이를 기본키로 추가한다.(없으면 대체키를 추가한다)
> 💡고객 테이블 내 집주소, 회사주소가 있을 때 집주소와 회사주소만 관리하면 되면 고객 테이블 내에서 속성을 명확히하여 관리하면 되지만 다른 주소를 추가해야 할 경우 제 1정규화에 위배되므로 고객 주소 테이블을 별도로 설계하는 게 맞다.
### 🟠제 2정규화
![](https://velog.velcdn.com/images/wruoma/post/bb1033d7-bfaa-444c-a3eb-46e94295fca8/image.png)
- 제 1정규화를 만족하고, 후보키에 종속적이지 않거나 후보키 일부 어트리뷰트에 종속적인 어트리뷰트는 별도 테이블을 생성하여 관리한다.
### 🟠제 3정규화
![](https://velog.velcdn.com/images/wruoma/post/8f543774-a14f-4b38-9724-19a048716269/image.png)
- 제 2정규화를 만족하고, 키가 아닌 어떤 어트리뷰트가 다른 어트리뷰트에 종속된 경우 별도 릴레이션으로 분리해야한다.
