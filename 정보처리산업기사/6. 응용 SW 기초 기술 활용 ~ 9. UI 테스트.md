## 📌필수 능력단위
- 애플리케이션 배포
- 화면 구현
- 애플리케이션 테스트 수행
- 프로그래밍 언어 응용
- 프로그래밍 언어 활용
- 응용 SW 기초 기술 활용
- 개발자 환경 구축
- SQL 활용
- UI 테스트
---
## 📌응용SW 기초 기술 활용
### 🟢OSI 7계층
#### Application Layer 상위 계층
- 7. 표현 계층(Application)
  - 서비스 제공, 입출력 정의, 응용 프로세스 관리
  - L7 스위치, 웹 방화벽
- 6. 응답 계층(Presentation)
  - 데이터 표현 방식을 상호 인식 가능하도록 변환, 인코딩·암호화·압출·코드 변환
- 5. 세션 계층(Session)
  - 프로세스간 연결 관리, 통신 오류 복구 및 재전송
#### Data Flow Layer 하위 계층
- 4. 전송 계층(Transport)
  - 세그먼트 구성, 포트 지정, 메세지 분할/조립, 프로세스 혼잡·흐름·오류 제어 및 재전송
  - 로드밸런서, 방화벽
- 3. 네트워크 계층(Network)
  - 패킷 구성, IP 지정
  - 라우터, L3 스위치
- 2. 데이터 링크 계층(Data Link)
  - 프레임 구성, 오류·흐름·접근 제어, MAC 지정
  - NIC, L2 스위치
- 1. 물리 계층(Physical)
  - 비트 스트림 전기 신호 전송,  비트 부호화·복호화, 물리적 연결 설정/해제
  - 허브, 리피터, 케이블

### 🟠인캡슐레이션/디캡슐레이션
> Body에는 상위 계층에서 받은 메세지를 추가하고 해당 계층에서 생성된 정보는 Header에 추가한다.
- 인캡슐레이션: 상위 계층에서 발생한 데이터를 하위 계층으로 이동시키면서 각 계층에서 처리한 결과를 캡슐화
  - 전송(Transport) 계층: 전송 순번, 출발지, Port 번호 추가/Segment 생성
  - 네트워크(Network) 계층: 출발지, 도착지, IP 추가/Packet 생성
  - 데이터 링크(Data Link) 계층: 출발지, MAC, FCS 추가/Frame 생성
  - 물리(Physical) 계층: Frame을 물리 전기 신호로 부호화하여 수신지에 전송한다.(이후 디캡슐레이션 진행)
- 디캡슐레이션: 하위 계층에서 인식한 데이터를 상위 계층으로 이동시키면서 각 네트워크 계층에서 처리 가능한 형태로 디캡슐화

### 🔵라우팅
- 정적(Static) 라우팅: 관리자가 직접 라우팅 경로를 입력하는 방법
- 동적(Dynamic) 라우팅: 직접 입력하지않고 라우터 간에 정보를 교환하여 경로를 관리하는 방법
  - 거리 백터 라우팅 알고리즘: 인접 라우터와 라우팅 테이블 정보를 교환하는 방법
    - RIP: 정기적으로 라우팅 테이블 정보를 인접 라우터와 교환하여 자신의 라우팅 테이블을 갱신하는 방법
  - 링크 상태 라우팅 알고리즘: 연결된 모든 라우터로부터 정보를 수신하여 최단 경로를 라우팅 테이블로 생성하는 방법
    - OSPT: 라우터의 연결 상태가 변경된 경우 모든 라우터에 자신의 변경 정보를 전달하는 방법

### 🟢미들웨어
- 운영체제와 응용소프트웨어 사이에서 다양한 기능을 지원하는 소프트웨어
  - 분산 시스템 SW: 다수 컴퓨터 환경에서 사용자가 하나의 시스템처럼 사용할 수 있도록 구성한 소프트웨어
    - 웹 애플리케이션, 연계 통합 솔루션, 실시간 데이터 처리, 분산 병렬 처리, TP 모니터
  - IT 자원 관리: IT 자원 관리 정책 기반으로 모니터링하며 성능/가용성을 관리하는 소프트웨어
    - 시스템 관리, SW 실행 관리, 네트워크 관리, IT 서비스 운영 관리
  - 서비스 플랫폼: 다른 서비스들을 통합 환경에서 상호 작용할 수 있도록 해주는 환경 구성 기술
    - IoT 플랫폼, 클라우드 서비스 플랫폼, UI/UX 프레임워크, CDN
  - 네트워크 보안: 불법적인 서비스 이용을 방지하는 기술
    - 네트워크 접근 제어, 보안 통신, 침입 방지/사고 대응, 보안 관리

### 🟠전자정부 표준프레임워크
- 전자정부 표준프레임워크 구성 요소/기능
  - 실행환경: 개발 표준 지원
  - 개발환경: 개발에 필요한 오픈소스 SW 지원
  - 운영환경: 서비스 운영
  - 관리환경: 시스템 배포/운영 관리
  - 공통컴포넌트: 공통 기능으로 재사용 가능한 컴포넌트 제공

### 🔵Scouter
#### 애플리케이션 성능 관리(APM) 도구
- Scouter 구성
  - Agent: WAS, DB 등 모니터링 대상의 성능을 측정하고 결과를 Server로 전송
  - Server: 측정된 결과 수집/저장
  - Client: Server에 수집된 정보 확인(서버 요청 응답 현황, 응답 평균속도, CPU 사용량, JVM 메모리 사용량, GC 시간 등)

### 🟢데이터베이스 개념
- 실시간 접근성: 요청된 데이터는 실시간으로 처리되고 결과를 반환해야 함
- 계속적 변화: 저장된 데이터는 입력/수정/삭제에 의해 지속적으로 변함
- 동시 공용: 다른 목적의 응용 SW 및 사용자에 의해 동시 공용 가능
- 내용에 의한 참조: 데이터 참조는 데이터 주소가 아닌 저장된 값에 의해 처리됨

### 🟠DBMS(데이터베이스 관리 시스템)
- 동시 제어성: 다수 트랜잭션으로부터 데이터 무결성 확보
- 회복 관리: 데이터 손실 및 결함 대응
- 성능 관리: 데이터 처리 속도 확보
- 보안 관리: 접근 제어 및 중요 정보의 암호화

### 🔵데이터베이스 종류
- 계층형: HDB, 한 레코드는 필드로 구성되며 다른 레코드들의 포인터로 구성/빠른 접근 속도/유연성 낮음
- 망형: N(Network)DB, 레코드에 부모 레코드의 포인터도 관리 가능, 유연성 좋음, 데이터 모델링 복잡함
- 관계형: R(Relational)DB, 데이터 간의 관계 구조 관리, 레코드의 집합을 테이블로 구성, 동적 변화로 유연성 높음
- 객체지향형: OO(Object Oriented)DB, 객체 재사용/캡슐화/상속 가능, 데이터 모델링 복잡함
- 객체관계형: OO(Object Relational)DB, 기존 RDB에 객체 개념을 적용, 데이터 모델링 용이

### 🟢트랜잭션(Transaction)
- DB의 상태를 변화시키기 위한 최소 작업 단위
- 한번에 처리되어야 하는 질의어(SQL)의 묶음
#### 트랜잭션 특징(ACID)
- Atomicity(원자성): 트랜잭션은 모두 반영되거나 전혀 반영되지 않아야 함
- Consistency(일관성): 시작 시점에 참조한 데이터는 종료까지 일관성을 유지해야 함
- Isolation(고립성): 다수 트랜잭션이 처리되는 경우 서로의 연산에 개입하면 안됨
- Durability(지속성): 트랜잭션이 완료되면 처리 결과는 영속적으로 반영되어야 함

### 🟠데이터 모델링
각 데이터를 도출 후 세부 속성과 식별자를 정의하고 데이터 간의 관계를 정해진 표기법으로 시각화하는 과정
#### 데이터 모델링 유형
- 요구사항 수집/분석: 사용자와 데이터베이스 용도 식별, 요구사항 수집/분석, 요구사항 정의서 작성
- 설계
  - 개념 모델링: 정보 추상화, 주제 영역 정의, 개념 도출, 개념 ERD 작성
  - 논리 모델링: 특정 데이터베이스에 적합하도록 구조화, 논리 ERD 작성
  - 물리 모델링: 특정 DBMS에서 활용 가능하도록 물리 ERD, 테이블 정의서 작성
- 데이터베이스 구현: 물리 ERD, 테이블 정의서를 이용해 특정 DBMS에 데이터베이스를 구축하는 과정

### 🔵ER 데이터 모델
현실세계의 구성 요소들을 DB로 관리하기 위해 유형화, 집단화, 일반화 과정을 통해 추상화하여 개체와 관계로 구조화한 데이터 모델
#### ER 데이터 모델의 구성
- 개체(Entity): 사람·사물·사건 등 유무형의 특성 실체화한 인스턴스의 집합, 유일한 식별자에 의해 식별 가능해야 하며 하나 이상의 속성과 관계로 구성되어야 함
- 속성(Attribute): 개체를 구성하는 특성
- 관계(Relationship): 개체 간 상호 연관성을 표현

## 📌개발자 환경 구축
### 🟢운영체제
컴퓨터 시스템이 제공하는 하드웨어와 소프트웨어 기능을 사용할수 있도록 해주는 시스템 소프트웨어
#### 운영체제 기능
1. 처리능력 향상
2. 응답시간 단축
3. 신뢰도 향상
4. 컴퓨터 시스템과 사용자 간 인터페이스 기능 제공
5. 출력 역할 지원
6. 프로그램과 사용자 간 보호
7. 주이거 장치 관리
8. CPU를 통한 프로그램 실행 관리
9. 컴퓨터 시스템 내 파일 관리
10. 컴퓨터 시스템 명령어 해석/수행
#### 운영체제 종류
윈도우 OS, UNIX, iOS, Android

### 🟠윈도우 기본 명령어 종류
- systeminfo: 시스템 정보 확인
- regedit: 레지스트리 편집기 실행
- sysedit: 시스템 구성 편집기
- telnet open 사이트 주소: 텔넷 접속 명령어
- netstat -na: 네트워크 상태 확인
- sfc: 시스템 파일 검사기
- services.msc: 윈도 서비스 확인
- perfmon.msc: 성능 모니터 뷰
- secpol.msc: 로컬 보안 설정
- mstsc.exe: 원격 데스크톱 연결 사용
- compmg mt.msc: 컴퓨터 관리
- devmgm t.msc: 장치 관리자
- dir: 현재 폴더에 있는 목록 확인

### 🔵리눅스 기본 명령어 종류
- ls: 현재 위치 파일목록 조회
- cd: 디렉터리 이동
- cp: 파일 복사
- mv: 파일 이동
- rm: 파일 제거
- mkdir: 디렉터리 생성
- cat: 파일 내용을 화면에 출력
- redirection: 화면 출력 결과를 파일로 저장
- alias: 자주 수행하는 명령어 설정

### 🟢운영체제 프로세스
애플리케이션 작업 우선 순위를 조정할 수 있다.
#### 운영체제 프로세스 특징
1. 실행중이거나 실행이 가능한 프로그램
2. 운영체제 내 PCB를 가진 프로그램
3. 목적/결과에 따라 발생하는 사건 과정
4. 프로세스는 병행 수행 가능
5. CPU는 수시로 프로세스 사이를 다중화하여 전환
6. 지정 결과를 얻기위한 계통적 동작
7. 비동기적 행위
8. 프로세스 할당 개체로 디스패치 가능
#### 운영체제 프로세스 종류
1. 순차 프로세스: 하나의 명령어만 프로세스를 대표하여 수행
2. 병행 프로세스: 프로그램 그 자체가 프로세스는 아니며 하나의 프로그램은 수동적 단위, 하나의 프로세스는 능동적 단위다.
#### 준비 리스트와 대기 리스트
1. 준비 리스트: 우선순위를 부여하여 가장 높은 우선순위 프로세스가 다음 순서에 CPU를 가진다.
2. 대기 리스트: 우선순위가 존재하지 않는다.

## 📌SQL 활용
### 🟢데이터 사전(Data Dicionary)
데이터베이스의 데이터를 제외한 모든 정보가 있으며 내용 변경 권한은 시스템 사용자(DB 관리자: DBA)가 가진다. <br>
일반 사용자는 단순 조회만 가능한 읽기 전용 테이블 형태가 제공된다.
#### 내용
1. 사용자 정보(ID, PWD, 권한 등)
2. 데이터베이스 객체(테이블, 인덱스, 뷰 등)
3. 무결성 제약 상태
4. 함수, 프로시저, 트리거 정보 등
#### 영역
- DBA_: 데이터베이스의 모든 객체 조회 가능(== 시스템 접근 권한)
- ALL_: 자신의 계정으로 접근할 수 있는 객체와 다른 계정에 접근 가능한 권한을 가진 모든 객체 조회 가능
- USER_: 현재 자신의 계정이 소유한 객체 조회 가능

### 🟠SQL 작성
> DDL(데이터 정의)
- 스키마(Schema): 하나의 데이터베이스
- 도메인(Domain): 속성의 데이터 타입과 제약 조건 등을 설정한 정보
- 테이블(Table): 데이터 저장 공간
- 뷰(View): 1개 이상의 물리 테이블을 통해 만드는 가상 테이블
  - 장점
    - 논리적 독립성 제공
    - 사용자 데이터 관리 용이
    - 데이터 보안 용이
  - 단점
    - 뷰의 인덱스 사용 불가: 인덱스를 만들 수 없음
    - 뷰 구조 변경 불가: 뷰는 삭제 후 재생성을 통해 뷰의 구조 변경이 가능함
    - 데이터 변경 제약 존재: 뷰로 조회된 데이터에 대한 삽입/변경/삭제 제약이 있음
- 인덱스(Index): 빠른 검색을 위한 검색 구조
```sql
CREATE [UNIQUE] INDEX <인덱스명> ON <테이블명> (<칼럼명 나열>);
```
> 테이블 생성 제약조건
- PRIMARY KEY(PK): 기본 키, NOT NULL&UNIQUE 제약 사항 설정
- FOREIGN KEY(FK): 외래 키, 참조 대상을 테이블명 형식으로 작성해야 함, 참조 무결성 위배 시 다음 옵션으로 처리 가능(CASCADE, NO ACTION, SET NULL, SET DEFAULT)
- UNIQUE: 테이블에 해당하는 열 값은 유일해야 함, 테이블에서 모든 값이 다르게 적재되어야 하는 열에 설정
- NOT NULL: 테이블에서 해당하는 열의 값은 NULL 불가능, 필수적으로 입력해야 하는 항목에 설정
- CHECK: 사용자가 직접 정의하는 제약 조건

>DML(다중 테이블 조회)
- 조인: 두개의 테이블을 결합하여 데이터 추출, 교집합, 세개 이상의 테이블을 조인할 경우 두개의 테이블을 우선적으로 조인 후 조인 결과와 나머지 한개 테이블을 다시 조인함
  - 내부 조인(Inner Join): 두 테이블에 공통으로 있는 칼럼을 활용
  - 동등 조인(Equi Join): 공통으로 있는 칼럼 값이 같은 경우에 레코드 추출
  - 자연 조인(Natural Join): 두 테이블에 있는 동일 칼럼을 기준으로 모든 칼럼 값이 같은 경우에 레코드를 추출
  - 교차 조인(Cross Join): 조인 조건이 없는 모든 데이터의 조합을 추출
  - 외부 조인(Outer Join): 특정 테이블 내 모든 데이터를 기준으로 다른 테이블의 정보와 비교하여 추출(다른 테이블에 동일한 값이 없어도 특정 테이블은 출력됨)
  - 왼쪽 외부 조인(Left Outer Join): 왼쪽 테이블의 모든 데이터와 오른쪽 테이블의 동일한 데이터를 추출(오른쪽 테이블에 동일한 값이 없어도 왼쪽 테이블의 레코드는 출력됨)
  - 오른쪽 외부 조인(Right Outer Join): 오른쪽 테이블의 모든 데이터와 왼쪽 테이블의 동일한 데이터를 추출(왼쪽 테이블에 동일한 값이 없어도 오른쪽 테이블의 레코드는 출력됨)
  - 완전 외부 조인(Full Outer Join): 양쪽의 모든 데이터를 추출(오른쪽과 왼쪽 테이블에 동일한 값이 없어도 오른쪽, 왼쪽 테이블의 레코드는 출력됨)
- 서브쿼리: SQL문 안에 포함된 또 다른 SQL문을 말하며 아직 확인되지 않은 기준을 검색하는 용도로 사용함
  - 동작하는 방식에 따른 서브쿼리
    - 비연관(Un-Correlated) 서브쿼리: 서브쿼리 내 메인쿼리 칼럼 정보를 가지고 있지 않음
    - 연관(Correlated) 서브쿼리: 서브쿼리 내 메인쿼리 칼럼 정보를 가지고 있음
  - 반환되는 데이터 형태에 따른 서브쿼리
    - Single Row(단일 행) 서브쿼리: 서브쿼리 결과가 항상 1 이하인 서브쿼리(=, <, <=, >, >=, <> ..)
    - Multiple Row(다중 행) 서브쿼리: 서브쿼리 실행 결과가 여러 건인 서브쿼리(IN, EXISTS, ALL, ANY ..)
    - Multiple Column(다중 칼럼) 서브쿼리: 서브쿼리 실행 결과가 2개 이상 칼럼으로 반환되는 쿼리
- 집합 연산자: 테이블을 집합 개념으로 조작
  - UNION: 2개 이상의 SQL문 실행 결과에 중복을 제거한 합집합
  - UNION ALL: 2개 이상의 SQL문 실행 결과에 대한 중복을 제거하지 않은 합집합
  - INTERSECTION: 2개 이상의 SQL문 실행 결과에 대한 중복을 제거한 교집합
  - EXCEPT(MINUS): 선행 SQL문 실행 결과와 후행 SQL문 실행 결과 사이의 중복을 제거한 차집합

> DCL(데이터 제어)
- 사용자 권한: 접근 통제, DBMS에 접근할 사용자 등록 후 특정 사용자에게 데이터베이스 사용 권한을 부여
- 트랜잭션: 안전하고 무결한 거래 보장, 동시 다발적으로 발생하는 다수 작업을 독립적이고 안전하게 처리하기 위한 데이터베이스

---

## 📌데이터 입출력 구현
### 🟢데이터 모델링 목적
1. 정보 요구에 대한 정확한 이해를 할 수 있음
2. 사용자, 설계자, 개발자 간 의수소통 수단 제공
3. 고품질 S/W와 유지보수 비용의 감소효과 기대
4. 신규/개선 시스템 개발 기초 제공

### 🟠데이터 모델링 특성
1. 업무 흐름 파악이 용이함
2. 데이터 무결성을 보장함
3. 데이터 중복을 제거하고 일관성있는 데이터를 제공함

### 🔵데이터 모델링 절차
- 개념 데이터 모델링
  - 주요 엔터티 타입, 기본 속성, 관계, 주요 업무기능 포함
  - 엔터티 타입 관계를 파악하여 업무 규칙을 정의
  - 논리 데이터 모델의 기초
- 논리 데이터 모델링
  - 모든 엔터티 타입, 속성, 관계, 프로세스 포함
  - 데이터를 정규화(Normalization)하여 모델링
  - 모든 업무 규칙과 관계를 완전하고 정확하게 표현
  - 특정 DBMS로부터 독립적
- 물리 데이터 모델링
  - 물리 구조로 변환
  - 설계용 엔터티 타입/설계용 속성 오브젝트 추가
  - 설계/성능을 고려한 조정 수행
  - 적용 DBMS에 적합한 성능 조정 수행

### 🟢정규화
#### 정의
중복성을 최소화하고 정보의 일관성을 보장하기 위한 개념
#### 목적
1. 데이터 중복 배제로 저장 공간의 최소화
2. 데이터 모형 단순화
3. 데이터 구조의 안정성 및 무결성 유지
4. 속성 배열상태 검증
5. 엔터티 속성 누락 여부 검증
6. 자료 검색과 추출의 효율성 추구
#### 특징
정규화된 데이터 모델은 **정확성·일치성·단순성·비중복성·안정성** 을 보장한다.
1. 제 1정규화: 반복 속성/Group 속성 제거, 새로운 실체와 1:N 관계 추가, 모든 속성은 반드시 하나의 값을 가져야 함(반복 형태 불가능)
2. 제 2정규화: 주식별자에 완전히 종속되지않는 속성 제거, 불완전 함수적 종속 제거, 모든 속성은 반드시 UID(식별자) 전부에 종속되어야 함(일부 종속 불가능)
3. 제 3정규화: 비식별자에 종속되는 속성 제거, 주식별자에 이행종속되는 속성 제거, UID가 아닌 모든 속성 간에는 서로 종속될 수 없음(종속성 배제)
- 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 데이터의 정확성이 높아지나 물리적 접근이 복잡하고 길이가 짧은 데이터 생성으로 과도한 조인이 발생할 수 있다.

### 🟠반정규화
#### 정의
정규화 모델링을 수행하면 종속성, 활용성은 향상되나 수행속도가 증가하는 경우가 발생하기 때문에 성능에 중점을 두어 정규화하는 방법
#### 특징
1. 데이터 모델링 규칙에 얽매이지 않고 수행
2. 물리적으로 구현되었을 때 성능향상 목적
#### 사용시기
1. 수행속도에 문제가 있는 경우
2. 다량의 범위를 자주 처리해야 하는 경우
3. 특정 범위의 데이터만 자주 처리하는 경우
4. 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우
5. 요약 자료만 주로 요구되는 경우
#### 유형
1. 중복 테이블 추가: 다량의 범위를 자주 처리하는 경우/특정 범위 데이터만 자주 처리되는 경우/처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우에 사용함, 집계 테이블 추가(원본 테이블에 트리거 생성), 진행 테이블 추가, 특정 부분만 포함하는 테이블 추가
2. 테이블 조합: 대부분의 처리가 두개 이상의 테이블에서 같이 일어나는 경우에 사용함, 해당 테이블을 통합하여 설계, row수의 증가로 처리량이 증가하는 경우가 발생함
3. 테이블 분할: 칼럼의 사용 빈도 차이가 많은 경우/각각의 사용자가 특정 부분만 지속적으로 사용하는 경우에 사용함, 수직분할, 수평분할
4. 테이블 제거: 더 이상 액세스되지 않는 테이블이 발생할 경우 사용함, 해당 테이블 삭제
5. 칼럼의 중복화: 자주 사용되는 칼럼이 다른 테이블에 분산되어 있으나 액세스 범위를 줄이지 못하는 경우/성능향상을 위한 파생 칼럼을 추가할 경우/정규화 규칙에 얽매이지 않으면서 성능 향상을 목적으로 한 반정규화를 통한 중복 데이터를 허용하는 경우에 사용함, 필요한 해당 테이블/칼럼을 추가함

### 🔵테이블 제약조건
- Delete Constraint
  - Cascade: 참조 테이블의 외부키와 일치하는 모든 row 삭제
  - Restricted: 참조 테이블의 외부키에 없는것만 삭제
  - Nullify: 참조 테이블에 정의된 외부키와 일치하는 것을 Null로 수정
- Update Constraint
  - Cascade: 참조 테이블의 외부키와 일치하는 모든 row 수정
  - Restricted: 참조 테이블의 외부키에 없는 것만 수정 가능
  - Nullify: 참조 테이블에 정의된 외부키와 일치하는 것을 Null로 수정(해당 칼럼이 Null을 허용한 경우만)

### 🟢View 설계
#### 속성
1. REPLACE: 뷰가 존재하는 경우 재생성
2. FORCE: 기본 테이블의 존재 여부에 관계없이 뷰 생성
3. NOFORCE: 기본 테이블이 존재할 때만 뷰 생성
4. WITH CHECK OPTION: Sub-Query 내 조건을 만족하는 행만 변경
5. WITH READ ONLY: DML 작업 불가
#### 고려사항
1. 테이블을 액세스하기 때문에 수행속도에 문제가 발생할 수 있음
2. 뷰 내 SELECT문 조건은 최적의 액세스를 경로할 수 있도록 하거나 SQL WHERE절은 반드시 양호한 액세스 경로가 되도록 해야 함

### 🟠파티션 설계
#### 종류
1. 범위분할(Range Partitioning): 지정 열의 값을 기준으로 분할
2. 해시분할(Hash Partitioning): 해시 함수에 따라 데이터를 분할
3. 조합분할(Composite Partitioning): 범위 분할에 의해 데이터를 분할 후 해시 함수를 적용하여 다시 분할
#### 장점
1. 데이터 액세스 범위를 줄여 성능 향상
2. 훼손 가능성 감소/데이터 가용성 향상
3. 분할 영역을 독립적으로 백업/복구 가능
4. Disk Striping으로 I/O 성능 향상
#### 파티셔닝 순서
파티션 종류 결정 -> 파티션 키 설정 -> 파티션 수 설정

### 🔵SQL 분류
#### 데이터 정의어(DDL)
테이블 구조 생성/변경, 명령어 수행 후 이전 상태로 복귀할 수 없음
- CREATE(오브젝트 생성): CREATE TABLE MY_TABLE;
- DROP(오브젝트 삭제): DROP TABLE MY_TABLE;
- RENAME(오브젝트 이름 변경): RENAME MY_TABLE TO MY_BACKUP_TABLE;
- ALTER(오브젝트 구조 변경): ALTER TABLE DEPT_COPY MODIFY(LOC VARCHAR2(14));
- TRUNCATE(오브젝트 자름): TRUNCATE TABLE DEPT_COPY;
#### 데이터 조작어(DML)
변경하거나 검색하기 위한 명령어, 트랜잭션 제어어(Transaction Control Language)를 활용하여 실행 전 상태로 복귀 가능
- INSERT(데이터 입력): INSERT INTO MY_TABLE VALUES(..) -- 입력하고자 하는 모든 칼럼을 입력한다면 칼럼명 생략이 가능하나 특정 칼럼에만 입력한다면 반드시 칼럼명을 명시해야함
- UPDATE(데이터 수정): UPDATE EMP SET EMPNO = 1234 [ , ENAME= 'JAMES'] WHERE EMPNO = 1111;
- DELETE(데이터 삭제): DELETE [FROM] MY_TABLE WHERE MY_FIELD2 = 'ABCD';
#### 데이터 제어어(DCL)
데이터베이스에 접근할 수 있는 권한을 부여하거나 회수하는 명령어
- ROLE(롤): CREATE ROLE ROLE_NAME; -- ROLE_NAME 선언 후 GRANT로 권한을 ROLE_NAME으로 부여함
- CONNECT(데이터베이스 접속 권한), RESOURCE(Object 생성 권한), DBA(모든 권한) -- Oracle에서 일반적으로 많이 사용하는 권한을 묶어 3가지 기본 Role을 제공함
- GRANT(권한 및 롤 부여): GRANT 부여할 권한 유형 TO USER [ROLE_NAME];
- REVOKE(권한 및 롤 회수): REVOKE 회수할 권한 유형 FROM User;
#### 트랜잭션 제어어(TCL)
트랜잭션의 DML 작업 단위를 제어하는 명령어
- COMMIT
  - 트랜잭션을 완료하여 데이터 변경사항을 최종 변경
  - 데이터에 대한 변경 사항이 물리적인 디스크에 반영
  - COMMIT 이전 데이터는 복구 불가능
  - 모든 사용자가 변경된 결과를 볼 수 있음
  - 관련된 행에 대해 잠금(LOCK)이 풀리며 다른 사용자들이 조작할 수 있음
- ROLLBACK
  - 데이터 변경사항을 이전 상태로 되돌림
  - ROLLBACK된 DML 문장은 메모리 상 Buffer에만 영향을 미치기 때문에 복구 가능
  - 관련된 행에 대한 잠금(LOCK)이 풀리게 됨
- SAVEPOINT
  - 지정된 특정 시점까지 Rollback할 수 있음

### 🟢데이터 검색어(SELECT)
```sql
SELECT [DISTINCT] {*, column [alias], . . .} -- DISTINCET: 중복 행 제거, *: 테이블 내 모든 칼럼 출력, alias: 해당 칼럼에 대해 다른 이름을 부여
FROM table_name
[WHERE condition] -- WHERE: 조건을 만족하는 행만 검색
[GROUP BY column] -- GROUP BY: 그룹핑하고자 하는 단위 지정
[HAVING condition] -- HAVING: 그립핑한 결과 값에 대한 조건 검색
[ORDER BY {column, expression} [ASC | DESC]]; -- ORDER BY: 질의 결과 정렬을 위한 옵션(ASC: 오름차순 default, DESC: 내림차순)
```

### 🟠PL/SQL
#### 개요
최근 프로그래밍 언어의 특성을 수용한 SQL의 확장 기능
#### 장점
1. 컴파일 필요없이 script 생성/변경 후 바로 실행 가능
2. 프로그램 개발의 모듈화
3. 식별자 선언 가능
4. 절차적 언어 구조로 된 프로그램 작성 가능(if문, loop문, explicit cursor를 이용한 multi-row 처리 가능)
5. ERROR 처리 가능
6. 성능 향상 기대
#### 구조
1. 선언부(DECLARE, Optional): 실행부에서 참조할 모든 변수, 상수, CURSOR, EXCEPTION 선언
2. 실행부(BEGIN/END, Mandatory): BEGIN/END 사이에 기술되는 영역, 데이터베이스 데이터를 처리할 SQL문과 PL/SQL 블록을 기술
3. 예외 처리부(Exception, Optional): 실행부에서 에러 발생 시 수행될 문장을 기술

### 🔵PL/SQL을 활용한 저장형 객체
- Stored Function: 값 계산 후 결과 값을 반환하기 위해 사용, 구성이 프로시저와 유사하지만 IN 파라미터만 사용 가능, 반드시 반환 값 뒤에 데이터 타입을 RETURN문에 선언해야 함, PL/SQL 블록 내 RETURN문을 통해 반드시 값을 반환해야 함
- Stored Procedure: 특정 작업을 수행할 수 있는 이름있는 PL/SQL 블록, 매개변수를 받을 수 있고 반복적으로 사용 가능한 Object, 연속 실행/구현이 복잡한 트랜잭션을 수행하는 PL/SQL 블록을 DB에 저장하기 위해 생성함
- Stored Package: 오라클 데이터베이스에 저장되어 있는 서로 관련있는 PL/SQL 프로시저와 함수들의 집합
- Trigger: INSERT, UPDATE, DELETE문이 테이블에 수행될 때 묵시적으로 수행되는 PROCEDURE, 테이블과는 별도로 데이터베이스에 저장됨, Trigger는 뷰에 대해서가 아니라 테이블에 관해서만 정의될 수 있음
