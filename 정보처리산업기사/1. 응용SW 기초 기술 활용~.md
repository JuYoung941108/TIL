**18:50~ ?**

## 📌응용SW 기초 기술 활용
### 🟢OSI 7계층
#### Application Layer 상위 계층
- 7. 표현 계층(Application)
  - 서비스 제공, 입출력 정의, 응용 프로세스 관리
  - L7 스위치, 웹 방화벽
- 6. 응답 계층(Presentation)
  - 데이터 표현 방식을 상호 인식 가능하도록 변환, 인코딩·암호화·압출·코드 변환
- 5. 세션 계층(Session)
  - 프로세스간 연결 관리, 통신 오류 복구 및 재전송
#### Data Flow Layer 하위 계층
- 4. 전송 계층(Transport)
  - 세그먼트 구성, 포트 지정, 메세지 분할/조립, 프로세스 혼잡·흐름·오류 제어 및 재전송
  - 로드밸런서, 방화벽
- 3. 네트워크 계층(Network)
  - 패킷 구성, IP 지정
  - 라우터, L3 스위치
- 2. 데이터 링크 계층(Data Link)
  - 프레임 구성, 오류·흐름·접근 제어, MAC 지정
  - NIC, L2 스위치
- 1. 물리 계층(Physical)
  - 비트 스트림 전기 신호 전송,  비트 부호화·복호화, 물리적 연결 설정/해제
  - 허브, 리피터, 케이블

### 🟠인캡슐레이션/디캡슐레이션
> Body에는 상위 계층에서 받은 메세지를 추가하고 해당 계층에서 생성된 정보는 Header에 추가한다.
- 인캡슐레이션: 상위 계층에서 발생한 데이터를 하위 계층으로 이동시키면서 각 계층에서 처리한 결과를 캡슐화
  - 전송(Transport) 계층: 전송 순번, 출발지, Port 번호 추가/Segment 생성
  - 네트워크(Network) 계층: 출발지, 도착지, IP 추가/Packet 생성
  - 데이터 링크(Data Link) 계층: 출발지, MAC, FCS 추가/Frame 생성
  - 물리(Physical) 계층: Frame을 물리 전기 신호로 부호화하여 수신지에 전송한다.(이후 디캡슐레이션 진행)
- 디캡슐레이션: 하위 계층에서 인식한 데이터를 상위 계층으로 이동시키면서 각 네트워크 계층에서 처리 가능한 형태로 디캡슐화

### 🔵라우팅
- 정적(Static) 라우팅: 관리자가 직접 라우팅 경로를 입력하는 방법
- 동적(Dynamic) 라우팅: 직접 입력하지않고 라우터 간에 정보를 교환하여 경로를 관리하는 방법
  - 거리 백터 라우팅 알고리즘: 인접 라우터와 라우팅 테이블 정보를 교환하는 방법
    - RIP: 정기적으로 라우팅 테이블 정보를 인접 라우터와 교환하여 자신의 라우팅 테이블을 갱신하는 방법
  - 링크 상태 라우팅 알고리즘: 연결된 모든 라우터로부터 정보를 수신하여 최단 경로를 라우팅 테이블로 생성하는 방법
    - OSPT: 라우터의 연결 상태가 변경된 경우 모든 라우터에 자신의 변경 정보를 전달하는 방법

### 🟢미들웨어
- 운영체제와 응용소프트웨어 사이에서 다양한 기능을 지원하는 소프트웨어
  - 분산 시스템 SW: 다수 컴퓨터 환경에서 사용자가 하나의 시스템처럼 사용할 수 있도록 구성한 소프트웨어
    - 웹 애플리케이션, 연계 통합 솔루션, 실시간 데이터 처리, 분산 병렬 처리, TP 모니터
  - IT 자원 관리: IT 자원 관리 정책 기반으로 모니터링하며 성능/가용성을 관리하는 소프트웨어
    - 시스템 관리, SW 실행 관리, 네트워크 관리, IT 서비스 운영 관리
  - 서비스 플랫폼: 다른 서비스들을 통합 환경에서 상호 작용할 수 있도록 해주는 환경 구성 기술
    - IoT 플랫폼, 클라우드 서비스 플랫폼, UI/UX 프레임워크, CDN
  - 네트워크 보안: 불법적인 서비스 이용을 방지하는 기술
    - 네트워크 접근 제어, 보안 통신, 침입 방지/사고 대응, 보안 관리

### 🟠전자정부 표준프레임워크
- 전자정부 표준프레임워크 구성 요소/기능
  - 실행환경: 개발 표준 지원
  - 개발환경: 개발에 필요한 오픈소스 SW 지원
  - 운영환경: 서비스 운영
  - 관리환경: 시스템 배포/운영 관리
  - 공통컴포넌트: 공통 기능으로 재사용 가능한 컴포넌트 제공

### 🔵Scouter
#### 애플리케이션 성능 관리(APM) 도구
- Scouter 구성
  - Agent: WAS, DB 등 모니터링 대상의 성능을 측정하고 결과를 Server로 전송
  - Server: 측정된 결과 수집/저장
  - Client: Server에 수집된 정보 확인(서버 요청 응답 현황, 응답 평균속도, CPU 사용량, JVM 메모리 사용량, GC 시간 등)

### 🟢데이터베이스 개념
- 실시간 접근성: 요청된 데이터는 실시간으로 처리되고 결과를 반환해야 함
- 계속적 변화: 저장된 데이터는 입력/수정/삭제에 의해 지속적으로 변함
- 동시 공용: 다른 목적의 응용 SW 및 사용자에 의해 동시 공용 가능
- 내용에 의한 참조: 데이터 참조는 데이터 주소가 아닌 저장된 값에 의해 처리됨

### 🟠DBMS(데이터베이스 관리 시스템)
- 동시 제어성: 다수 트랜잭션으로부터 데이터 무결성 확보
- 회복 관리: 데이터 손실 및 결함 대응
- 성능 관리: 데이터 처리 속도 확보
- 보안 관리: 접근 제어 및 중요 정보의 암호화

### 🔵데이터베이스 종류
- 계층형: HDB, 한 레코드는 필드로 구성되며 다른 레코드들의 포인터로 구성/빠른 접근 속도/유연성 낮음
- 망형: N(Network)DB, 레코드에 부모 레코드의 포인터도 관리 가능, 유연성 좋음, 데이터 모델링 복잡함
- 관계형: R(Relational)DB, 데이터 간의 관계 구조 관리, 레코드의 집합을 테이블로 구성, 동적 변화로 유연성 높음
- 객체지향형: OO(Object Oriented)DB, 객체 재사용/캡슐화/상속 가능, 데이터 모델링 복잡함
- 객체관계형: OO(Object Relational)DB, 기존 RDB에 객체 개념을 적용, 데이터 모델링 용이

### 🟢트랜잭션(Transaction)
- DB의 상태를 변화시키기 위한 최소 작업 단위
- 한번에 처리되어야 하는 질의어(SQL)의 묶음
#### 트랜잭션 특징(ACID)
- Atomicity(원자성): 트랜잭션은 모두 반영되거나 전혀 반영되지 않아야 함
- Consistency(일관성): 시작 시점에 참조한 데이터는 종료까지 일관성을 유지해야 함
- Isolation(고립성): 다수 트랜잭션이 처리되는 경우 서로의 연산에 개입하면 안됨
- Durability(지속성): 트랜잭션이 완료되면 처리 결과는 영속적으로 반영되어야 함

### 🟠데이터 모델링
각 데이터를 도출 후 세부 속성과 식별자를 정의하고 데이터 간의 관계를 정해진 표기법으로 시각화하는 과정
#### 데이터 모델링 유형
- 요구사항 수집/분석: 사용자와 데이터베이스 용도 식별, 요구사항 수집/분석, 요구사항 정의서 작성
- 설계
  - 개념 모델링: 정보 추상화, 주제 영역 정의, 개념 도출, 개념 ERD 작성
  - 논리 모델링: 특정 데이터베이스에 적합하도록 구조화, 논리 ERD 작성
  - 물리 모델링: 특정 DBMS에서 활용 가능하도록 물리 ERD, 테이블 정의서 작성
- 데이터베이스 구현: 물리 ERD, 테이블 정의서를 이용해 특정 DBMS에 데이터베이스를 구축하는 과정

### 🔵ER 데이터 모델
현실세계의 구성 요소들을 DB로 관리하기 위해 유형화, 집단화, 일반화 과정을 통해 추상화하여 개체와 관계로 구조화한 데이터 모델
#### ER 데이터 모델의 구성
- 개체(Entity): 사람·사물·사건 등 유무형의 특성 실체화한 인스턴스의 집합, 유일한 식별자에 의해 식별 가능해야 하며 하나 이상의 속성과 관계로 구성되어야 함
- 속성(Attribute): 개체를 구성하는 특성
- 관계(Relationship): 개체 간 상호 연관성을 표현

## 📌개발자 환경 구축
### 🟢운영체제
컴퓨터 시스템이 제공하는 하드웨어와 소프트웨어 기능을 사용할수 있도록 해주는 시스템 소프트웨어
#### 운영체제 기능
1. 처리능력 향상
2. 응답시간 단축
3. 신뢰도 향상
4. 컴퓨터 시스템과 사용자 간 인터페이스 기능 제공
5. 출력 역할 지원
6. 프로그램과 사용자 간 보호
7. 주이거 장치 관리
8. CPU를 통한 프로그램 실행 관리
9. 컴퓨터 시스템 내 파일 관리
10. 컴퓨터 시스템 명령어 해석/수행
#### 운영체제 종류
윈도우 OS, UNIX, iOS, Android

### 🟠윈도우 기본 명령어 종류
- systeminfo: 시스템 정보 확인
- regedit: 레지스트리 편집기 실행
- sysedit: 시스템 구성 편집기
- telnet open 사이트 주소: 텔넷 접속 명령어
- netstat -na: 네트워크 상태 확인
- sfc: 시스템 파일 검사기
- services.msc: 윈도 서비스 확인
- perfmon.msc: 성능 모니터 뷰
- secpol.msc: 로컬 보안 설정
- mstsc.exe: 원격 데스크톱 연결 사용
- compmg mt.msc: 컴퓨터 관리
- devmgm t.msc: 장치 관리자
- dir: 현재 폴더에 있는 목록 확인

### 🔵리눅스 기본 명령어 종류
- ls: 현재 위치 파일목록 조회
- cd: 디렉터리 이동
- cp: 파일 복사
- mv: 파일 이동
- rm: 파일 제거
- mkdir: 디렉터리 생성
- cat: 파일 내용을 화면에 출력
- redirection: 화면 출력 결과를 파일로 저장
- alias: 자주 수행하는 명령어 설정

### 🟢운영체제 프로세스
애플리케이션 작업 우선 순위를 조정할 수 있다.
#### 운영체제 프로세스 특징
1. 실행중이거나 실행이 가능한 프로그램
2. 운영체제 내 PCB를 가진 프로그램
3. 목적/결과에 따라 발생하는 사건 과정
4. 프로세스는 병행 수행 가능
5. CPU는 수시로 프로세스 사이를 다중화하여 전환
6. 지정 결과를 얻기위한 계통적 동작
7. 비동기적 행위
8. 프로세스 할당 개체로 디스패치 가능
#### 운영체제 프로세스 종류
1. 순차 프로세스: 하나의 명령어만 프로세스를 대표하여 수행
2. 병행 프로세스: 프로그램 그 자체가 프로세스는 아니며 하나의 프로그램은 수동적 단위, 하나의 프로세스는 능동적 단위다.
#### 준비 리스트와 대기 리스트
1. 준비 리스트: 우선순위를 부여하여 가장 높은 우선순위 프로세스가 다음 순서에 CPU를 가진다.
2. 대기 리스트: 우선순위가 존재하지 않는다.

## 📌프로그래밍 언어 활용
### 🟢객체지향 프로그래밍 설계
#### 객체지향 속성
- 캡슐화: 객체 속성과 행위를 하나로 묶고 실제 구현 내용 일부를 외부에 감추어 은닉함
- 추상화: 공통 부분이나 관심있는 특성을 하나로 모음(공통 메소드를 인터페이스로 묶는 것도 해당됨)
- 다형성: 같은 모양의 메소드가 상황에 따라 다르게 동작하게함
  - 오버로딩: 매개 변수 숫자, 타입 등을 다르게 해서 사용함
  - 오버라이딩: 상위 클래스 메소드를 하위 클래스에서 같은 이름으로 재정의함
- 정보 은닉: 캡슐화된 정보들을 밖에서 접근 불가능하도록 은닉함
- 상속성: 부모 클래스에서 정의된 것들을 자동으로 상속받아 구현함
#### 객체지향 설계 원칙
- 단일 책임 원칙(Single Responsiblity Principle)
  - 모든 클래스는 각각 하나의 책임만 가져야하며 클래스는 그 책임을 완전히 캡슐화해야한다.
-  개방-폐쇄 원칙(Open Closed Principle)
  - 확장에는 열려있고 수정에는 닫혀있어 코드를 변경하지않고 기능을 추가할 수 있도록 설계되어야한다.
-  리스코프 치환 원칙(Liskov Substitution Principle)
  - 자식 클래스는 부모 클래스의 책임을 무시하거나 재정의하지 않고 확장만 수행하도록 해야한다.
- 인터페이스 분리 원칙(Interface Segregation Principle)
  - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야한다.
- 의존 역전 원칙(Dependency Inversion Principle)
  - 구체적인 클래스보다 인터페이스나 추상 클래스와 관계를 맺어야한다.
#### UML
- 유즈케이스 다이어그램: 시스템 개발 과정에서 의사소통이 원활하게 이루어지도록 표준화한 대표적 객체지향 모델링 언어
- 클래스 다이어그램: 클래스 내부 구성요소 및 클래스간의 관계를 도식화한 다이어그램
  - 속성: 명사형으로 많이 표현되며 클래스의 멤버 변수로 사용됨
  - 행동: 해당 클래스가 수행할 수 있는 오퍼레이션을 가지며 메소드로 사용됨
- 시퀀스 다이어그램: 문제 해결을 위한 객체를 정의하고 객체 간 상호작용 메세지 시퀀스를 시간의 흐름에 따라 나타낸 다이어그램
  - 활성 객체: 라이프 라인을 가짐
  - 메세지: 자신의 객체 라이프 라인으로부터 다른 객체 라이프 라인까지 선+화살표로 표시되며 메세지는 그 위에 작성함
  - 활성 박스: 객체의 특정 메소드 실행 혹은 메소드의 종료를 기다리는 것을 나타냄

### 🟠접근 지정자
- public: 모든 접근 허용
- protected: 자기 자신 클래스와 상속받은 자식 클래스만 접근 허용
- private: 자기 자신 클래스의 내부 메소드만 접근 가능
- default: 같은 패키지 내 모든 접근 가능하나 다른 패키지는 접근 불가능

### 🔵디자인 패턴
객체지향 프로그래밍 시 발생하는 문제에 대한 설계 사례를 분석하여 공통 발생 문제를 해결하기 위한 방법론
#### 디자인 패턴 구조
1. 콘텍스트(Context): 문제가 발생하는 여러 상황을 기술
2. 문제(Problem): 패턴이 적용되어 해결될 필요가 있는 여러 디자인 이슈들을 기술
3. 해결(Solution): 설계 구성 요소와 요소 사이의 책임 관계, 협력 관계를 기술
#### 디자인 패턴 종류
- 생성 패턴: Abstract Factory, Builder, Factory Methods, Prototype, Singleton
- 구조 패턴: Adaptor, Bridge, Composite, Decorator, Facade, Flyweight, Proxy
- 행위 패턴: Chain of Responsibillity, Command, Interpreter, Iterpreter, Mediator, Memonto, Observer, State, Strategy, Template Method, Visitor

### 🟢스크립트 프로그래밍 언어 유형
- Javascript: 미국 넷스케이프사 개발, 표준 html 문서 내 삽입되어 사용됨
- jQuery: html 문서에 삽입하여 사용할 수 있는 자바스크립트 라이브러리
- JSP: html 페이지에 자바 코드를 삽입하여 웹 브라우저로 전달하는 프로그래밍 언어
- PHP: html 문서 내 포함하여 작동하는 서버 측 스크립트 프로그래밍 언어
- ASP: 윈도 서버에서 운영할 수 있도록 개발된 스크립트 방식의 웹 프로그래밍 언어
#### 스크립트 프로그래밍 원리
스크립트 코드 작성 -> byte code 변환 -> 기계어 변환 -> CPU 코드 변환

## 📌프로그래밍 언어 응용
### 🟢빌드 방식에 따른 분류
프로그램 소스코드가 실행 가능한 형태로 변하는 과정을 빌드(Build)라고 하며 빌드 방식에 따라 분류할 수 있다.
1. 컴파일(Compile) 언어: 소스코드가 기계어 실행 파일로 빌드됨(C, C++)
2. 인터프리터(Interpreter) 언어: 소스코드를 한 줄씩 번역하여 실행함(Python)
3. 바이트 코드(Byte Code) 언어: 컴파일을 통해 가상머신이 번역할 수 있는 Byte Code로 변환되며 가상머신은 다시 Native OS가 이해할 수 있는 기계어로 변역함(Java, Scala)

### 🟠컴파일러와 인터프리터 비교
![image](https://user-images.githubusercontent.com/109946081/219867910-392d80c2-0a88-4588-9609-33707df66b37.png)


### 🔵코드 인스펙션(Code Inspection)
소스코드를 실행하지 않고 코드상에서 결함을 식별하여 개선하는 기법
#### 인스펙션 수행 절차
- 계획(Planning)
- 개관(Overview): 참여자에게 산출물에 대한 이해도를 높여 인스펙션 효과성을 개선함
- 준비(Preparation): 구성원은 결함 부분에 대해 기록함
- 검토회의(Meeting): 산출물 검토 후 식별된 결함 부분에 대해 집중함
- 재작업(Rework): 검토회의에서 발견된 결함을 수정함
- 추적(Follow-up): 결함이 정상적으로 수정되었는지 확인 후 인스펙션을 종료함

### 🟢리팩토링(Refactoring)
SW의 원래 기능을 유지하면서 소스코드의 내부 구조를 수정/보완하여 가독성, 성능 향상, 로직을 개선하는 기법
#### 리팩토링 방법
![image](https://user-images.githubusercontent.com/109946081/219866941-05e5cdc7-751f-46c1-a430-0e13227e79c5.png)

### 🟠OWASP TOP 10
웹 애플리케이션에 대한 보안 프로젝트로 애플리케이션 취약점 중 빈도가 많이 발생하고 보안상 영향을 크게 줄 수 있는 10가지를 선정하여 발표한다.
- 인젝션(Injection): 웹 애플리케이션에 비정상적 명령어나 Query 등을 보내 공격자가 시스템에 불법적으로 접근할 수 있는 취약점
- 취약한 인증(Broken Authentication): 잘못 구현된 인증, Session 관리로 일시적/영구적으로 공격자가 다른 사용자의 권한을 취득할 수 있는 취약점
- 민감한 데이터 노출(Sensitive Data Exposure): 개인 식별 정보, 신용 정보 등 민감 데이터 저장 및 전송 시 노출 취약점
- XML 외부 개체(XXE: XML External Entities): XML 문서 내 External Entity를 이용해 공격자가 외부 URL을 실행하여 서버 로컬 파일 정보를 출력하거나 서비스 거부 공격을 수행할 수 있는 취약점
- 잘못된 보안 구성(Security misconfigurations): 안전하지 않은 구성/잘못된 구성으로 HTTP Header나 민감 정보가 포함된 에러 메세지 등으로 인한 취약점
- 크로스 사이트 스크립팅(XSS: Cross Site Scripting): 사용자의 정보(쿠키/세션 등)를 탈취하거나 악의적인 사이트로 이동할 수 있는 취약점
- 안전하지 않은 역직렬화(Insecure Deserialization): 데이터를 역직렬화하는 과정에서 원격코드 실행이나 권한 상승 등이 가능한 취약점
- 알려진 취약점이 있는 구성요소 사용(Using Components with Known Vulnerabilities): 취약한 컴포넌트가 악용되는 경우 서버가 장악되거나 심각한 데이터 손실을 발생할 수 있는 취약점
- 불충분한 로깅 및 모니터링(Insufficient logging and monitoring): 충분하지 않은 로깅과 모니터링을 통해 시스템을 추가로 공격하고 데이터를 변조하거나 추출, 파괴 가능한 취약점

### 🔵정적 분석과 PMD
- 정적 분석(Static Analysis): 소스코드의 실행없이 코드의 의미를 분석해 결함을 찾아내는 기법
- PMD(Programing Mistake Detector): 정적 분석을 위한 오픈 소스 코드 분석 도구로 이클립스 등과 같은 IDE에 플로그인 형태로 배포됨

### 🟢라이브러리, 프레임워크, 아키텍처, 플랫폼 비교
![image](https://user-images.githubusercontent.com/109946081/219868132-23511682-a57f-4a77-b326-f5c4c630718d.png)

### 🟠모듈과 패키지
- Module: 한개의 파일에서 기능을 제공함
- Package: 여러 개 모듈을 한개의 폴더에 묶어서 제공함

### 🔵Maven
1. 빌드 도구(Build Tool): 소스코드 파일을 컴퓨터에서 실행할 수 있는 가공물로 변환하는 과정으로 프로젝트 생성/빌드/배포 등의 작업을 위한 도구
2. Maven: Apache Maven/자바용 프로젝트 관리 도구, 필요한 라이브러리를 pom.xml에 정의하여 내가 사용할 라이브러리 뿐만 아니라 관련 라이브러리까지 네트워크를 통해 자동으로 다운로드해주는 오픈소스 소프트웨어

### 🟢빌드 도구 비교
- Ant: XML 기반의 빌드 스크립트 작성
- Maven: XML 기반으로 작성, 생명주기/POM 개념 도입, pom.xml 파일을 이용해 dependency를 추가하고 삭제하여 라이브러리를 관리함
- Gradle: Ant와 Maven의 장점을 모아놓음, 의존성 관리를 위한 다양한 방법 제공, xml이 아닌 jvm에서 실행되는 groovy를 사용함

## 📌데이터 입출력 구현
### 🟢데이터 모델링 목적
1. 정보 요구에 대한 정확한 이해를 할 수 있음
2. 사용자, 설계자, 개발자 간 의수소통 수단 제공
3. 고품질 S/W와 유지보수 비용의 감소효과 기대
4. 신규/개선 시스템 개발 기초 제공

### 🟠데이터 모델링 특성
1. 업무 흐름 파악이 용이함
2. 데이터 무결성을 보장함
3. 데이터 중복을 제거하고 일관성있는 데이터를 제공함

### 🔵데이터 모델링 절차
- 개념 데이터 모델링
  - 주요 엔터티 타입, 기본 속성, 관계, 주요 업무기능 포함
  - 엔터티 타입 관계를 파악하여 업무 규칙을 정의
  - 논리 데이터 모델의 기초
- 논리 데이터 모델링
  - 모든 엔터티 타입, 속성, 관계, 프로세스 포함
  - 데이터를 정규화(Normalization)하여 모델링
  - 모든 업무 규칙과 관계를 완전하고 정확하게 표현
  - 특정 DBMS로부터 독립적
- 물리 데이터 모델링
  - 물리 구조로 변환
  - 설계용 엔터티 타입/설계용 속성 오브젝트 추가
  - 설계/성능을 고려한 조정 수행
  - 적용 DBMS에 적합한 성능 조정 수행

### 🟢정규화
#### 정의
중복성을 최소화하고 정보의 일관성을 보장하기 위한 개념
#### 목적
1. 데이터 중복 배제로 저장 공간의 최소화
2. 데이터 모형 단순화
3. 데이터 구조의 안정성 및 무결성 유지
4. 속성 배열상태 검증
5. 엔터티 속성 누락 여부 검증
6. 자료 검색과 추출의 효율성 추구
#### 특징
정규화된 데이터 모델은 **정확성·일치성·단순성·비중복성·안정성** 을 보장한다.
1. 제 1정규화: 반복 속성/Group 속성 제거, 새로운 실체와 1:N 관계 추가, 모든 속성은 반드시 하나의 값을 가져야 함(반복 형태 불가능)
2. 제 2정규화: 주식별자에 완전히 종속되지않는 속성 제거, 불완전 함수적 종속 제거, 모든 속성은 반드시 UID(식별자) 전부에 종속되어야 함(일부 종속 불가능)
3. 제 3정규화: 비식별자에 종속되는 속성 제거, 주식별자에 이행종속되는 속성 제거, UID가 아닌 모든 속성 간에는 서로 종속될 수 없음(종속성 배제)
- 정규화 수준이 높을수록 유연한 데이터 구축이 가능하고 데이터의 정확성이 높아지나 물리적 접근이 복잡하고 길이가 짧은 데이터 생성으로 과도한 조인이 발생할 수 있다.

### 🟠반정규화
#### 정의
정규화 모델링을 수행하면 종속성, 활용성은 향상되나 수행속도가 증가하는 경우가 발생하기 때문에 성능에 중점을 두어 정규화하는 방법
#### 특징
1. 데이터 모델링 규칙에 얽매이지 않고 수행
2. 물리적으로 구현되었을 때 성능향상 목적
#### 사용시기
1. 수행속도에 문제가 있는 경우
2. 다량의 범위를 자주 처리해야 하는 경우
3. 특정 범위의 데이터만 자주 처리하는 경우
4. 처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우
5. 요약 자료만 주로 요구되는 경우
#### 유형
1. 중복 테이블 추가: 다량의 범위를 자주 처리하는 경우/특정 범위 데이터만 자주 처리되는 경우/처리 범위를 줄이지 않고는 수행 속도를 개선할 수 없는 경우에 사용함, 집계 테이블 추가(원본 테이블에 트리거 생성), 진행 테이블 추가, 특정 부분만 포함하는 테이블 추가
2. 테이블 조합: 대부분의 처리가 두개 이상의 테이블에서 같이 일어나는 경우에 사용함, 해당 테이블을 통합하여 설계, row수의 증가로 처리량이 증가하는 경우가 발생함
3. 테이블 분할: 칼럼의 사용 빈도 차이가 많은 경우/각각의 사용자가 특정 부분만 지속적으로 사용하는 경우에 사용함, 수직분할, 수평분할
4. 테이블 제거: 더 이상 액세스되지 않는 테이블이 발생할 경우 사용함, 해당 테이블 삭제
5. 칼럼의 중복화: 자주 사용되는 칼럼이 다른 테이블에 분산되어 있으나 액세스 범위를 줄이지 못하는 경우/성능향상을 위한 파생 칼럼을 추가할 경우/정규화 규칙에 얽매이지 않으면서 성능 향상을 목적으로 한 반정규화를 통한 중복 데이터를 허용하는 경우에 사용함, 필요한 해당 테이블/칼럼을 추가함

### 🔵테이블 제약조건
- Delete Constraint
  - Cascade: 참조 테이블의 외부키와 일치하는 모든 row 삭제
  - Restricted: 참조 테이블의 외부키에 없는것만 삭제
  - Nullify: 참조 테이블에 정의된 외부키와 일치하는 것을 Null로 수정
- Update Constraint
  - Cascade: 참조 테이블의 외부키와 일치하는 모든 row 수정
  - Restricted: 참조 테이블의 외부키에 없는 것만 수정 가능
  - Nullify: 참조 테이블에 정의된 외부키와 일치하는 것을 Null로 수정(해당 칼럼이 Null을 허용한 경우만)

### 🟢View 설계
#### 속성
1. REPLACE: 뷰가 존재하는 경우 재생성
2. FORCE: 기본 테이블의 존재 여부에 관계없이 뷰 생성
3. NOFORCE: 기본 테이블이 존재할 때만 뷰 생성
4. WITH CHECK OPTION: Sub-Query 내 조건을 만족하는 행만 변경
5. WITH READ ONLY: DML 작업 불가
#### 고려사항
1. 테이블을 액세스하기 때문에 수행속도에 문제가 발생할 수 있음
2. 뷰 내 SELECT문 조건은 최적의 액세스를 경로할 수 있도록 하거나 SQL WHERE절은 반드시 양호한 액세스 경로가 되도록 해야 함

### 🟠파티션 설계
#### 종류
1. 범위분할(Range Partitioning): 지정 열의 값을 기준으로 분할
2. 해시분할(Hash Partitioning): 해시 함수에 따라 데이터를 분할
3. 조합분할(Composite Partitioning): 범위 분할에 의해 데이터를 분할 후 해시 함수를 적용하여 다시 분할
#### 장점
1. 데이터 액세스 범위를 줄여 성능 향상
2. 훼손 가능성 감소/데이터 가용성 향상
3. 분할 영역을 독립적으로 백업/복구 가능
4. Disk Striping으로 I/O 성능 향상
#### 파티셔닝 순서
파티션 종류 결정 -> 파티션 키 설정 -> 파티션 수 설정

### 🔵SQL 분류
#### 데이터 정의어(DDL)
테이블 구조 생성/변경, 명령어 수행 후 이전 상태로 복귀할 수 없음
- CREATE(오브젝트 생성): CREATE TABLE MY_TABLE;
- DROP(오브젝트 삭제): DROP TABLE MY_TABLE;
- RENAME(오브젝트 이름 변경): RENAME MY_TABLE TO MY_BACKUP_TABLE;
- ALTER(오브젝트 구조 변경): ALTER TABLE DEPT_COPY MODIFY(LOC VARCHAR2(14));
- TRUNCATE(오브젝트 자름): TRUNCATE TABLE DEPT_COPY;
#### 데이터 조작어(DML)
변경하거나 검색하기 위한 명령어, 트랜잭션 제어어(Transaction Control Language)를 활용하여 실행 전 상태로 복귀 가능
- INSERT(데이터 입력): INSERT INTO MY_TABLE VALUES(..) -- 입력하고자 하는 모든 칼럼을 입력한다면 칼럼명 생략이 가능하나 특정 칼럼에만 입력한다면 반드시 칼럼명을 명시해야함
- UPDATE(데이터 수정): UPDATE EMP SET EMPNO = 1234 [ , ENAME= 'JAMES'] WHERE EMPNO = 1111;
- DELETE(데이터 삭제): DELETE [FROM] MY_TABLE WHERE MY_FIELD2 = 'ABCD';
#### 데이터 제어어(DCL)
데이터베이스에 접근할 수 있는 권한을 부여하거나 회수하는 명령어
- ROLE(롤): CREATE ROLE ROLE_NAME; -- ROLE_NAME 선언 후 GRANT로 권한을 ROLE_NAME으로 부여함
- CONNECT(데이터베이스 접속 권한), RESOURCE(Object 생성 권한), DBA(모든 권한) -- Oracle에서 일반적으로 많이 사용하는 권한을 묶어 3가지 기본 Role을 제공함
- GRANT(권한 및 롤 부여): GRANT 부여할 권한 유형 TO USER [ROLE_NAME];
- REVOKE(권한 및 롤 회수): REVOKE 회수할 권한 유형 FROM User;
#### 트랜잭션 제어어(TCL)
트랜잭션의 DML 작업 단위를 제어하는 명령어
- COMMIT
  - 트랜잭션을 완료하여 데이터 변경사항을 최종 변경
  - 데이터에 대한 변경 사항이 물리적인 디스크에 반영
  - COMMIT 이전 데이터는 복구 불가능
  - 모든 사용자가 변경된 결과를 볼 수 있음
  - 관련된 행에 대해 잠금(LOCK)이 풀리며 다른 사용자들이 조작할 수 있음
- ROLLBACK
  - 데이터 변경사항을 이전 상태로 되돌림
  - ROLLBACK된 DML 문장은 메모리 상 Buffer에만 영향을 미치기 때문에 복구 가능
  - 관련된 행에 대한 잠금(LOCK)이 풀리게 됨
- SAVEPOINT
  - 지정된 특정 시점까지 Rollback할 수 있음
